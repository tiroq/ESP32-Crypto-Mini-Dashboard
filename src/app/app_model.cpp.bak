#include "app_model.h"
#include "../config.h"
#include "app_config.h"
#include <freertos/FreeRTOS.h>
#include <freertos/semphr.h>

// Global state with FreeRTOS mutex protection
static AppState g_app_state;
static SemaphoreHandle_t g_model_mutex = NULL;

void model_init() {
    // Create mutex for thread-safe access
    if (g_model_mutex == NULL) {
        g_model_mutex = xSemaphoreCreateMutex();
        if (g_model_mutex == NULL) {
            DEBUG_PRINTLN("[MODEL] ERROR: Failed to create mutex!");
            return;
        }
    }
    
    // Initialize state without calling config functions that might have mutexes
    // Symbol names will be set lazily when first accessed
    g_app_state.selected_symbol_idx = 0;
    g_app_state.data_stale = true;
    g_app_state.wifi_connected = false;
    g_app_state.wifi_rssi = 0;
    strcpy(g_app_state.current_time, "--:--");
    
    DEBUG_PRINTLN("[MODEL] Initialized with thread-safe mutex");
    
    // Now it's safe to call config functions after mutex is created
    const AppConfig& cfg = config_get();
    
    // Initialize symbol configurations from config
    for (int i = 0; i < cfg.num_symbols && i < MAX_SYMBOLS; i++) {
        g_app_state.symbols[i].symbol_name = cfg.symbols[i].display_name;
        g_app_state.symbols[i].binance_symbol = cfg.symbols[i].binance_symbol;
        g_app_state.symbols[i].coinbase_product = cfg.symbols[i].coinbase_product;
    }
    
    // Start with first enabled symbol
    if (!config_is_symbol_enabled(0)) {
        g_app_state.selected_symbol_idx = config_get_next_enabled_symbol(0);
    }
    
    DEBUG_PRINTF("[MODEL] Configured symbols: %d total, %d enabled\n", 
                cfg.num_symbols, config_get_enabled_symbol_count());
    DEBUG_PRINTF("[MODEL] Selected symbol: %s\n", 
                cfg.symbols[g_app_state.selected_symbol_idx].display_name);
}

AppState model_snapshot() {
    AppState snapshot;
    
    if (g_model_mutex != NULL && xSemaphoreTake(g_model_mutex, pdMS_TO_TICKS(100)) == pdTRUE) {
        snapshot = g_app_state;  // Copy entire state
        xSemaphoreGive(g_model_mutex);
    } else {
        DEBUG_PRINTLN("[MODEL] WARNING: Failed to acquire mutex for snapshot");
    }
    
    return snapshot;
}

void model_update_symbol(int idx, const SymbolState& s) {
    if (idx < 0 || idx >= MAX_SYMBOLS) {
        DEBUG_PRINTF("[MODEL] ERROR: Invalid symbol index %d\n", idx);
        return;
    }
    
    if (g_model_mutex != NULL && xSemaphoreTake(g_model_mutex, portMAX_DELAY) == pdTRUE) {
        // Preserve configuration strings
        const char* name = g_app_state.symbols[idx].symbol_name;
        const char* binance_sym = g_app_state.symbols[idx].binance_symbol;
        const char* coinbase_prod = g_app_state.symbols[idx].coinbase_product;
        
        // Preserve history before update
        double old_history[PRICE_HISTORY_SIZE];
        int old_count = g_app_state.symbols[idx].history_count;
        int old_head = g_app_state.symbols[idx].history_head;
        for (int i = 0; i < PRICE_HISTORY_SIZE; i++) {
            old_history[i] = g_app_state.symbols[idx].price_history[i];
        }
        
        // Update state
        g_app_state.symbols[idx] = s;
        
        // Restore configuration strings
        g_app_state.symbols[idx].symbol_name = name;
        g_app_state.symbols[idx].binance_symbol = binance_sym;
        g_app_state.symbols[idx].coinbase_product = coinbase_prod;
        
        // Restore history
        for (int i = 0; i < PRICE_HISTORY_SIZE; i++) {
            g_app_state.symbols[idx].price_history[i] = old_history[i];
        }
        g_app_state.symbols[idx].history_count = old_count;
        g_app_state.symbols[idx].history_head = old_head;
        
        // Add current price to history if valid
        if (s.binance_quote.valid && s.binance_quote.price > 0) {
            g_app_state.symbols[idx].price_history[old_head] = s.binance_quote.price;
            g_app_state.symbols[idx].history_head = (old_head + 1) % PRICE_HISTORY_SIZE;
            if (old_count < PRICE_HISTORY_SIZE) {
                g_app_state.symbols[idx].history_count = old_count + 1;
            }
            DEBUG_PRINTF("[MODEL] Added price %.2f to history[%d/%d] head=%d count=%d\n", 
                          s.binance_quote.price, idx, old_head, 
                          g_app_state.symbols[idx].history_head, 
                          g_app_state.symbols[idx].history_count);
        }
        
        xSemaphoreGive(g_model_mutex);
        
        DEBUG_PRINTF("[MODEL] Updated symbol[%d]: %s\n", idx, name);
    } else {
        DEBUG_PRINTLN("[MODEL] WARNING: Failed to acquire mutex for update");
    }
}

void model_set_selected(int idx) {
    if (idx < 0 || idx >= MAX_SYMBOLS) {
        DEBUG_PRINTF("[MODEL] ERROR: Invalid symbol index %d\n", idx);
        return;
    }
    
    if (g_model_mutex != NULL && xSemaphoreTake(g_model_mutex, portMAX_DELAY) == pdTRUE) {
        g_app_state.selected_symbol_idx = idx;
        xSemaphoreGive(g_model_mutex);  // Release mutex BEFORE calling config_get()
    } else {
        DEBUG_PRINTLN("[MODEL] WARNING: Failed to acquire mutex for set_selected");
        return;
    }
    
    // Call config_get() outside of mutex to avoid priority inversion
    const AppConfig& cfg = config_get();
    DEBUG_PRINTF("[MODEL] Selected symbol: %s\n", cfg.symbols[idx].display_name);
}

int model_get_selected() {
    int idx = 0;
    
    if (g_model_mutex != NULL && xSemaphoreTake(g_model_mutex, portMAX_DELAY) == pdTRUE) {
        idx = g_app_state.selected_symbol_idx;
        xSemaphoreGive(g_model_mutex);
    } else {
        DEBUG_PRINTLN("[MODEL] WARNING: Failed to acquire mutex for get_selected");
    }
    
    return idx;
}

const char* model_get_symbol_name(int idx) {
    if (idx >= 0 && idx < MAX_SYMBOLS) {
        // No mutex needed - config is read-only after init
        const AppConfig& cfg = config_get();
        return cfg.symbols[idx].display_name;
    }
    return "UNKNOWN";
}

void model_update_wifi(bool connected, int rssi) {
    if (g_model_mutex != NULL && xSemaphoreTake(g_model_mutex, portMAX_DELAY) == pdTRUE) {
        g_app_state.wifi_connected = connected;
        g_app_state.wifi_rssi = rssi;
        xSemaphoreGive(g_model_mutex);
    }
}

void model_update_time(const char* time_str) {
    if (g_model_mutex != NULL && xSemaphoreTake(g_model_mutex, portMAX_DELAY) == pdTRUE) {
        strncpy(g_app_state.current_time, time_str, sizeof(g_app_state.current_time) - 1);
        g_app_state.current_time[sizeof(g_app_state.current_time) - 1] = '\0';
        xSemaphoreGive(g_model_mutex);
    }
}

void model_set_stale(bool stale) {
    if (g_model_mutex != NULL && xSemaphoreTake(g_model_mutex, portMAX_DELAY) == pdTRUE) {
        g_app_state.data_stale = stale;
        xSemaphoreGive(g_model_mutex);
    }
}
